# 现代js框架存在的深层原因
[The deepest reason why modern JavaScript frameworks exist](https://medium.com/dailyjs/the-deepest-reason-why-modern-javascript-frameworks-exist-933b86ebc445)

我看到很多很多人盲目的使用类似于react,angular,vue的前端框架.这些框架提供很多有趣的东西,但是人们忽略了他们存在的深层原因,不是因为以下的原因:

他们由组件构成
他们有很健壮的社区
他们有大量的第三方插件来处理事情
他们有很好用的第三方组件
他们有浏览器 扩展来帮助debug东西
他们对开发单页面应用很友好

本质、根本、最深层的原因是

保持UI和状态同步是困难的

是的,只有这个原因,然后让我们看下为什么
想象你实现一个用户可以通过介绍他的邮箱地址来邀请许多人的web应用.UX/UI设计者做了这样一个决定:这有一个展示帮助信息的label的空state,在其他情况(state),我们展示邮箱地址,在右边有一个button/link去删除他们.

表单的状态基本上是一个由邮件地址加一个唯一标识符组成的数组.开始的时候,这是空的.当通过添加文字和敲击回车来添加一个邮箱地址,你把输入的邮箱地址添加到数组中,并且更新了UI.当用户点击"delete",你删除邮箱地址并更新UI.你看到了吗?每当你改变state,你需要更新UI.

所以呢? 好的,看下我们如何在没有框架的帮助下实现上面的更新操作.

一个关于少量的复杂UI的普通实现

这代码很好说明用js实现一个小复杂的UI变化需要的工作量,(使用类似于jq之类的经典库,代码量也是类似的)

这个例子中,静态的体系在html上被创建,反之 动态的 素材在js里被创建(使用document.createElement).这里有一个问题:构建UI的js代码可读性不是很好而且我们需要在两个地方定义UI.我们可以使用innerHTML,它的可读性会好很多,但是效率低,而且会造成导致 跨 站 脚本的漏洞.我们也可以使用模板 引擎,但是如果你重新生成[再生]一个大的dom 树,你会有两个问题: 效率不高和你必须经常和事件处理重新建立连接.

但是,这不是最严重的问题.最严重的问题是在每次改变都会更新UI.每当state改变,就会有大量的代码去更新UI.当在实例中添加一个邮箱地址,花费了两行代码区更新state,但是13行代码去更新UI.而且我们尽可能的简单来设计UI！

这不仅仅是难以书写和难以推理,而且很重要的一点是:这也非常脆弱.设想我们需要实现一个从sever同步list的方法.我们将需要比较我们和服务端收到的data.这包括比较全部的id和内容(我们在内存中有一个不同数据相同id的记录副本)

我们将需要实现大量ad-hoc呈现代码有效改变DOM.如果我们产生了任何微小的错误,UI将会与数据不同步: 丢失信息,展示错误信息或者完全搞乱 elements对使用者没有做出相应或甚至 更加糟糕,触发错误的操作(例如 点击一个删除按钮删除错误的item).

所以,保持UI同步数据涉及写大量的繁琐的 虚弱的 不健壮的代码

公布的 UIS 营救

所以,不是社区,不是工具,也不是生态系统,也不是第三方库等等.
到目前为止,这些框架最大 改进是提供 有能力实现 保证应用内部状态同步 的 UIS.

好的，差不多了. 这是正确的 如果你没有打乱一些每个特别框架也许有的规则(比如 状态的不可改变性).

我们定义UI在单一的开枪[位置],不需要在每个方法中写特定的UI代码,而且由于一个特定的状态，我们总是获取相同的输出:当状态改编后,框架自动更新.

它是如何工作的?

这有两个基础的策略

重新render整个组件: react. 当组件状态发生改变,他会在内存中render DOM,并且将他和已存在的DOM进行比较.事实上,过程很昂贵的，它render一个虚拟DOM然后比较提供的虚拟DOM的 快照[之前的虚拟DOM].接着它计算改变和执行相同的改变在真实的DOM.这个过程被叫做reconciliation[和解].

使用观察者观察变化：Angular和Vue.观察状态变量,当状态变量涉及到时,再将该部分DOM进行改变.

web组件是怎么实现的?

很多时候,人们将web组件和react,angular,vue比较.这是一个清楚的指示器,很多人没有理解最大的好处这些框架提供的:保持UI状态的同步性.而且web组件在这方面没有提供任何东西.他们只是提供一个 template 标签,但是它没有提供任何的一致机能.如果你想要使用web组件,并且想在app中使UI与内部状态同步,你必须手动完成,或者你可以使用一些类似于Stencil.js(它内部使用了虚拟dom,类似于React).

让我们明确一点: 关于科技最大的潜力不是组件:他总是保持UI和state的同步. Web组件直接[开箱即用]没有提供任何东西关于同步的东西,而且你必须使用第三方库来解决这个问题(或者手动解决).这是不可能的去写复杂有效而且易于维护的UI通过基础的js.这就是最主要的原因你需要一个现代js框架.

自己动手干

我喜欢学习事情的原理,而且结果发现这是虚拟dom实现方式在这之外.所以, 为什么我们不尝试使用一个不依靠任何已有框架的帮助的虚拟dom去重写我们vanilla UI.

这是框架的核心,任何组件的基础类型.

而且这是 地址列表组件 重新实现.(通过一个babel的帮助来支持jsx)

现在UI是公开的,而且我们不用使用任何框架.我们可以实现新的逻辑在任何方法改变状态,而且我们不必写额外的代码来保持UI的同步.问题解决！

现在除了对事件的处理,这看起来有点像react app,是吗? 我们有xxx 方法,一旦我们解决了 保持UI 和 内部state 同步的问题,自然地每件事情都堆叠起来[好起来].

你可以在github项目中找到全部的源代码.

结论

现代框架解决最主要的问题就是 UI和state同步的问题.

这不必使用Vanilla JS 去写一个 复杂的 高效的 简单的 易于维护的 UIS.

web组件没有为这个问题提供一个解决方式。

不在困难使用一个已存在的虚拟DOM库来构造你自己的框架.但是 我不支持你这么做！